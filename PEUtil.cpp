#include "PEUtil.h"


//获取文件大小
int getFileSize(FILE *P_file){
	int filesize=0;
	if(P_file){
		fseek(P_file,0,SEEK_END);
		filesize=ftell(P_file);
		fseek(P_file, 0, SEEK_SET);
	}else{
		printf("getFileSize Failed---文件指针为NULL");
	}
	return filesize;
}

//读取到FileBuffer
//return 0 失败 1 成功
//函数声明							
//**************************************************************************							
//ReadPEFile:将文件读取到缓冲区							
//参数说明：							
//lpszFile 文件路径							
//pFileBuffer 缓冲区指针							
//返回值说明：							
//读取失败返回0  否则返回实际读取的大小							
//**************************************************************************							
DWORD ReadPEFile(IN LPSTR lpszFile,OUT LPVOID* pFileBuffer)		
{		
	FILE *pFile = NULL;	
	DWORD fileSize = 0;	
	LPVOID pFileBufferTmp=NULL;
		
	//打开文件	
    pFile = fopen(lpszFile, "rb");		
	if(!pFile)	
	{	
		printf("ReadPEFile Failed---无法打开EXE 文件,%s!\n",lpszFile);
		return 0;
	}	
    //读取文件大小		

    fileSize = getFileSize(pFile);		

	//分配缓冲区	
	pFileBufferTmp = malloc(fileSize);	
		
	if(!pFileBufferTmp)	
	{	
		printf("ReadPEFile  Failed---读取PE文件后分配空间失败%s!\n",lpszFile);
		fclose(pFile);
		pFile=NULL;
		return 0;
	}	

	memset(pFileBufferTmp,0,fileSize);

	//将文件数据读取到缓冲区	
	DWORD n = (DWORD)fread(pFileBufferTmp, fileSize, 1, pFile);	
	if(!n)	
	{	
		printf("ReadPEFile Failed---读取PE文件数据失败,%s!\n",lpszFile);
		free(pFileBufferTmp);
		fclose(pFile);
		pFile=NULL;
		pFileBufferTmp=NULL;
		return 0;
	}	

	if(!checkIsPEFile(pFileBufferTmp)){
		printf("ReadPEFile Failed---不是标准PE文件,%s!\n",lpszFile);
		free(pFileBufferTmp);
		fclose(pFile);
		pFile=NULL;
		pFileBufferTmp=NULL;
		return 0;
	}
	//关闭文件	
	fclose(pFile);
	pFile=NULL;
	*pFileBuffer=pFileBufferTmp;
	printf("ReadPEFile successed,%s!\n",lpszFile);
    return n;		
	
}

//**************************************************************************							
//CopyFileBufferToImageBuffer:将文件从FileBuffer复制到ImageBuffer							
//参数说明：							
//pFileBuffer  FileBuffer指针							
//pImageBuffer ImageBuffer指针							
//返回值说明：							
//读取失败返回0  否则返回复制的大小							
//**************************************************************************
DWORD CopyFileBufferToImageBuffer(IN LPVOID pFileBuffer,OUT LPVOID* pImageBuffer){

	if(!checkIsPEFile(pFileBuffer)){
		printf("CopyFileBufferToImageBuffer Failed---pFileBuffer不是标准PE文件!\n");
		return 0;
	}

	LPVOID pImageBufferTmp=NULL;
	PIMAGE_OPTIONAL_HEADER32 POptionPEHeader=getOptionHeader(pFileBuffer);
	DWORD sizeOfImage=POptionPEHeader->SizeOfImage;
	DWORD sizeOfHeaders=POptionPEHeader->SizeOfHeaders;
	PIMAGE_SECTION_HEADER pSectionHeader = getSectionHeader(pFileBuffer);
	WORD sectionNum=getSectionNum(pFileBuffer);
	
	pImageBufferTmp=malloc(sizeOfImage);
	if(!pImageBufferTmp){	

		printf("CopyFileBufferToImageBuffer---malloc PImageBuffer失败!\n");

		return 0;
	}
	
	memset(pImageBufferTmp,0,sizeOfImage);

	//============将pFileBuffer数据读取到pImageBuffer中=========

	//读取Headers

	memcpy(pImageBufferTmp,pFileBuffer,POptionPEHeader->SizeOfHeaders);

	DWORD virtualAddress=0;
	DWORD sizeOfRawData=0;
	DWORD pointerToRawData=0;

	
	//根据节表中的信息循环将FileBuffer中的节拷贝到ImageBuffer中
	DWORD i=0;
	for(i=0;i<sectionNum;i++)
	{
		virtualAddress=pSectionHeader->VirtualAddress;
		sizeOfRawData=pSectionHeader->SizeOfRawData;
		pointerToRawData=pSectionHeader->PointerToRawData;
		DWORD j=0;
		for(j=0;j<sizeOfRawData;j++){
			*((char*)pImageBufferTmp+virtualAddress+j)=*((char*)pFileBuffer+pointerToRawData+j);
		}
		
		pSectionHeader=pSectionHeader+1;

	}

	*pImageBuffer=pImageBufferTmp;

	return sizeOfImage;
}							
//**************************************************************************							
//CopyImageBufferToNewBuffer:将ImageBuffer中的数据复制到新的缓冲区，将ImageBuffer还原为文件的PE格式							
//参数说明：							
//pImageBuffer ImageBuffer指针							
//pNewBuffer NewBuffer指针							
//返回值说明：							
//读取失败返回0  否则返回复制的大小							
//**************************************************************************							
DWORD CopyImageBufferToNewBuffer(IN LPVOID pImageBuffer,OUT LPVOID* pNewBuffer){
	if(!checkIsPEFile(pImageBuffer)){
		printf("CopyImageBufferToNewBuffer Failed---pImageBuffer不是标准PE文件!\n");
		return 0;
	}
	LPVOID pNewBufferTmp=NULL;
	PIMAGE_OPTIONAL_HEADER32 POptionPEHeader=getOptionHeader(pImageBuffer);
	DWORD sizeOfHeaders=POptionPEHeader->SizeOfHeaders;
	
	WORD sectionNum=getSectionNum(pImageBuffer);
	PIMAGE_SECTION_HEADER pLastSectionHeader=getSection(pImageBuffer,sectionNum);

	DWORD pointerToRawDataLastSection=pLastSectionHeader->PointerToRawData;
	DWORD sizeOfRawDataLastSection=pLastSectionHeader->SizeOfRawData;
	DWORD sizeOfNewBuffer=pointerToRawDataLastSection+sizeOfRawDataLastSection;
	

	pNewBufferTmp=malloc(sizeOfNewBuffer);
	if(!pNewBufferTmp)	
	{	

		printf("CopyImageBufferToNewBuffer---malloc pNewBufferTmp失败!\n ");
		
		return 0;
	}
	
	memset(pNewBufferTmp,0,sizeOfNewBuffer);
	
	//============将pImageBuffer数据读取到pNewBuffer中=========
	PIMAGE_SECTION_HEADER pSectionHeader = getSectionHeader(pImageBuffer);
	DWORD i=0;
	//读取Headers
	for(i=0;i<sizeOfHeaders;i++)
	{
		*((char*)pNewBufferTmp+i)=*((char*)pImageBuffer+i);
	}

	DWORD virtualAddress=0;
	DWORD sizeOfRawData=0;
	DWORD pointerToRawData=0;


	//根据节表中的信息循环将pImageBuffer中的节拷贝到pNewBuffer中
	for(i=0;i<sectionNum;i++)
	{
		virtualAddress=pSectionHeader->VirtualAddress;
		sizeOfRawData=pSectionHeader->SizeOfRawData;
		pointerToRawData=pSectionHeader->PointerToRawData;
		DWORD j=0;
		for(j=0;j<sizeOfRawData;j++){
			*((char*)pNewBufferTmp+pointerToRawData+j)=*((char*)pImageBuffer+virtualAddress+j);
		}
		
		pSectionHeader=pSectionHeader+1;

	}

	*pNewBuffer=pNewBufferTmp;

	return sizeOfNewBuffer;
}							
//**************************************************************************							
//MemeryTOFile:将内存中的数据复制到文件							
//参数说明：							
//pMemBuffer 内存中数据的指针							
//size 要复制的大小							
//lpszFile 要存储的文件路径							
//返回值说明：							
//读取失败返回0  否则返回复制的大小							
//**************************************************************************							
DWORD MemeryTOFile(IN LPVOID pMemBuffer,IN size_t size,OUT LPSTR lpszFile){
	if(!checkIsPEFile(pMemBuffer)){
		printf("CopyImageBufferToNewBuffer Failed---pMemBuffer不是标准PE文件,%s!\n",lpszFile);
		return 0;
	}
	FILE *p_file=NULL;
	p_file=fopen(lpszFile,"wb");
	if(p_file){
		DWORD writeSize=(DWORD)fwrite(pMemBuffer,1,size,p_file);
		
		fclose(p_file);
		p_file=NULL;
		

		if(!writeSize){

				printf("MemeryTOFile---Write File failed!\n");
				return 0;
		}
		
		return writeSize;
	}

		printf("MemeryTOFile---open File failed!\n");
		return 0;
		
}							
//**************************************************************************							
//RvaToFileOffset:将内存偏移转换为文件偏移							
//参数说明：							
//pFileBuffer FileBuffer指针							
//dwRva RVA的值							
//返回值说明：							
//返回转换后的FOA的值  如果失败返回0							
//**************************************************************************							
DWORD RvaToFileOffset(IN LPVOID pFileBuffer,IN DWORD dwRva){
	if(!checkIsPEFile(pFileBuffer)){
		printf("RvaToFileOffset Failed---pFileBuffer不是标准PE文件!\n");
		return 0;
	}

	
	WORD sectionNum=getSectionNum(pFileBuffer);
	PIMAGE_SECTION_HEADER pSectionHeader = getSectionHeader(pFileBuffer);
	PIMAGE_OPTIONAL_HEADER32 POptionPEHeader=getOptionHeader(pFileBuffer);
	DWORD imageBase = POptionPEHeader->ImageBase;
	DWORD tmpImageHigh=dwRva-imageBase;
	DWORD i=0;
	DWORD virtualAddress=0;
	DWORD indexSection=0;
	for(i=0;i<sectionNum;i++){
		
		virtualAddress=pSectionHeader->VirtualAddress;
		DWORD misc=pSectionHeader->Misc.VirtualSize;
		
		if(tmpImageHigh>=virtualAddress && tmpImageHigh<=(virtualAddress+misc)){
			indexSection=i+1;
			//找到了所在节的位置
			return tmpImageHigh-virtualAddress+(pSectionHeader->PointerToRawData);
			
		}
		
		pSectionHeader=pSectionHeader+1;
	}

	
	return 0;
}

//**************************************************************************							
//FileOffsetToRva:将内存偏移转换为文件偏移							
//参数说明：							
//pFileBuffer FileBuffer指针							
//dwFileOffSet RVA的值							
//返回值说明：							
//返回转换后的RVA的值  如果失败返回0							
//**************************************************************************							
DWORD FileOffsetToRva(IN LPVOID pFileBuffer,IN DWORD dwFileOffSet){
	if(!checkIsPEFile(pFileBuffer)){
		printf("RvaToFileOffset Failed---pFileBuffer不是标准PE文件!\n");

		return 0;
	}

	
	WORD sectionNum=getSectionNum(pFileBuffer);
	PIMAGE_SECTION_HEADER pSectionHeader = getSectionHeader(pFileBuffer);
	PIMAGE_OPTIONAL_HEADER32 POptionPEHeader=getOptionHeader(pFileBuffer);
	DWORD imageBase = POptionPEHeader->ImageBase;


	DWORD i=0;
	DWORD virtualAddress=0;
	DWORD indexSection=0;
	for(i=0;i<sectionNum;i++){
		
		virtualAddress=pSectionHeader->VirtualAddress;
		DWORD misc=pSectionHeader->Misc.VirtualSize;
		DWORD pointerToRawData=pSectionHeader->PointerToRawData;
		DWORD sizeOfRawData=pSectionHeader->SizeOfRawData;
		
		if(dwFileOffSet>=pointerToRawData && dwFileOffSet<=(pointerToRawData+sizeOfRawData)){
			indexSection=i+1;
			//找到了所在节的位置
			return imageBase+virtualAddress+(dwFileOffSet-pointerToRawData);
			
		}
		
		pSectionHeader=pSectionHeader+1;
	}

	
	return 0;
}

//释放Buffer
void freePBuffer(LPVOID pBuffer){
	
		free(pBuffer);
		pBuffer=NULL;
	
}

//检查是不是PE文件
//return 0 失败 1 成功
int checkIsPEFile(LPVOID pBuffer){
		//判断是否是有效的MZ标志	
	if(*((PWORD)pBuffer) != IMAGE_DOS_SIGNATURE)	
	{	
		printf("不是有效的MZ标志\n");
		
		return 0; 
	}
	PIMAGE_DOS_HEADER pDosHeader = NULL;
	pDosHeader=getDosHeader(pBuffer);
		//判断是否是有效的PE标志	
	if(*((PDWORD)((DWORD)pBuffer+pDosHeader->e_lfanew)) != IMAGE_NT_SIGNATURE)	
	{	
		
		printf("不是有效的PE标志\n");
		
		return 0;
	}
	
	return 1;
}

//获取Dos文件头
PIMAGE_DOS_HEADER getDosHeader(LPVOID pBuffer){
	PIMAGE_DOS_HEADER pDosHeader = NULL;
	pDosHeader = (PIMAGE_DOS_HEADER)pBuffer;
	return pDosHeader;
}

//获得NT文件头
PIMAGE_NT_HEADERS getNTHeader(LPVOID pBuffer){
	PIMAGE_NT_HEADERS pNTHeader = NULL;
	PIMAGE_DOS_HEADER pDosHeader = NULL;
	pDosHeader=getDosHeader(pBuffer);
	pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pBuffer+pDosHeader->e_lfanew);
	return pNTHeader;
}


//获得PE文件头
PIMAGE_FILE_HEADER getPEHeader(LPVOID pBuffer){
	PIMAGE_FILE_HEADER pPEHeader = NULL;
	PIMAGE_NT_HEADERS pNTHeader = NULL;
	pNTHeader=getNTHeader(pBuffer);
	pPEHeader = (PIMAGE_FILE_HEADER)(((DWORD)pNTHeader) + 4);
	return pPEHeader;
}


//获得可选的PE头
PIMAGE_OPTIONAL_HEADER32 getOptionHeader(LPVOID pBuffer){
	PIMAGE_FILE_HEADER pPEHeader = NULL;
	PIMAGE_OPTIONAL_HEADER32 pOptionHeader = NULL;
	pPEHeader = getPEHeader(pBuffer);
	pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader+IMAGE_SIZEOF_FILE_HEADER);
	return pOptionHeader;
}

//获得节表头
PIMAGE_SECTION_HEADER getSectionHeader(LPVOID pBuffer){
	PIMAGE_FILE_HEADER pPEHeader = NULL;
	PIMAGE_OPTIONAL_HEADER32 pOptionHeader = NULL;
	PIMAGE_SECTION_HEADER pSectionHeader = NULL;
	
	
	pPEHeader = getPEHeader(pBuffer);
	pOptionHeader = getOptionHeader(pBuffer);
	WORD sizeOfOptionHeader=pPEHeader->SizeOfOptionalHeader;
	pSectionHeader=(PIMAGE_SECTION_HEADER)((char*)pOptionHeader+sizeOfOptionHeader);
	return 	pSectionHeader;
}

//获取节表了
//index 第几个节表
//返回值：成功返回该节表头，失败则返回NULL
PIMAGE_SECTION_HEADER getSection(LPVOID pBuffer,WORD index){
	PIMAGE_SECTION_HEADER pSectionHeader = NULL;
	PIMAGE_OPTIONAL_HEADER32 pOptionHeader = NULL;
	

	
	pSectionHeader=getSectionHeader(pBuffer);
	
	WORD sectionNum=getSectionNum(pBuffer);

	if(index<1 || index>sectionNum){
		printf("getSection Error,no section of this index:%d\n",index);
		return NULL;
	}

	pSectionHeader=pSectionHeader+(index-1);
	
	return pSectionHeader;

}	

//获得节的数量
WORD getSectionNum(LPVOID pBuffer){
	PIMAGE_FILE_HEADER pPEHeader = NULL;
	pPEHeader = getPEHeader(pBuffer);
	return pPEHeader->NumberOfSections;
}



//将ShellCode添加到某个Section中
//pathName:源文件路径
//pathNameDes:目标文件路径
//pshellCode:shellCode地址
//shellCodeLength:shellCode的长度
//sectionNum:节的地址了
//返回值:成功返回1,失败返回0
DWORD addShellCodeIntoSection(char* pathName,char* pathNameDes,PBYTE pshellCode,DWORD shellCodeLength,WORD sectionNum){

	LPVOID pFileBuffer=NULL;
	LPVOID pImageBuffer=NULL;
	LPVOID pNewFileBuffer=NULL;

	//FileToFileBuffer
	if(!ReadPEFile(pathName,&pFileBuffer)){
		return 0;
	}

	DWORD copySize=0;

	//FileBufferToImageBuffer
	copySize= CopyFileBufferToImageBuffer(pFileBuffer,&pImageBuffer);
	
	if(!copySize){
		freePBuffer(pFileBuffer);
		printf("addShellCodeIntoSection---CopyFileBufferToImageBuffer Failed!\n");	
		return 0;
	}
	
	PIMAGE_SECTION_HEADER pSectionHeader=getSection(pFileBuffer,sectionNum);
	
	if(!pSectionHeader){
		freePBuffer(pFileBuffer);	
		freePBuffer(pImageBuffer);
		printf("addShellCodeIntoSection Failed!---SectionNum:%d 不存在\n",sectionNum);	
		return 0;
	}

	if(!checkSectionHeaderCouldWriteCode(pSectionHeader,shellCodeLength)){
		freePBuffer(pFileBuffer);	
		freePBuffer(pImageBuffer);
		printf("addShellCodeIntoSection Failed!---Section:%d 没有足够的空间存放shellCode\n",sectionNum);
	}


	PBYTE pcodeBegin=NULL;
	pcodeBegin=getCodeBeginFromImageBuffer(pImageBuffer,pSectionHeader);
	

	//将shellCode复制到ImageBuffer对应section中
	memcpy(pcodeBegin,pshellCode,shellCodeLength);

	LPVOID pNewBuffer=NULL;
	
	
	copySize=CopyImageBufferToNewBuffer(pImageBuffer,&pNewBuffer);
	
	freePBuffer(pImageBuffer);

	if(!copySize){
		printf("CopyImageBufferToNewBuffer Failed!\n");
		return 0;
	}

	copySize=MemeryTOFile(pNewBuffer,copySize,pathNameDes);
	freePBuffer(pNewFileBuffer);

	if(!copySize){
		printf("MemeryTOFile Failed!\n");
		return 0;
	}

	return 1;
}


//判断Section是否足够存储shellCode的代码
//pSectionHeader:要放入代码的section的Header
//shellCodeLength:代码区长度
//返回值:成功则返回1，失败则返回0
DWORD checkSectionHeaderCouldWriteCode(IN PIMAGE_SECTION_HEADER pSectionHeader,DWORD shellCodeLength){
	if((pSectionHeader->SizeOfRawData<pSectionHeader->Misc.VirtualSize) || ((pSectionHeader->SizeOfRawData-pSectionHeader->Misc.VirtualSize)<shellCodeLength)){
		return 0;
	}
	return 1;
}



//从ImageBuffer中获得能够注入代码的位置
//返回注入的代码在ImageBuffer中的位置了
PBYTE getCodeBeginFromImageBuffer(IN LPVOID pImageBuffer,IN PIMAGE_SECTION_HEADER pSectionHeader){
	PBYTE pcodeBegin=NULL;
	pcodeBegin=(PBYTE)((DWORD)pImageBuffer+pSectionHeader->VirtualAddress+pSectionHeader->Misc.VirtualSize);
	return pcodeBegin;
}

//将ImageBuffer中的地址转换为运行时的地址
//pImageBuffer
//imageBufferRunAddr在ImageBuffer中的地址了
//返回运行时的地址
DWORD changeImageBufferAddressToRunTimeAddress(IN LPVOID pImageBuffer,DWORD imageBufferRunAddr){
	DWORD callAddressTo=0;
	PIMAGE_OPTIONAL_HEADER32 pOptionHeader = NULL;
	pOptionHeader = getOptionHeader(pImageBuffer);
	callAddressTo=((pOptionHeader->ImageBase)+(imageBufferRunAddr-(DWORD)pImageBuffer));
	
	return callAddressTo;
	
}

//将ImageBuffer中的地址转换为E8或E9指令后面跳转的地址的硬编码
//pImageBuffer
//imageBufferRunAddr在ImageBuffer中的地址了
//E8E9RunTimeAddress:E8或E9指令运行时的地址
DWORD changeE8E9AddressFromImageBuffer(IN LPVOID pImageBuffer,DWORD imageBufferRunAddr,DWORD E8E9RunTimeAddress){
	DWORD runTimeAddress=changeImageBufferAddressToRunTimeAddress(pImageBuffer,imageBufferRunAddr);
	DWORD returnAddressTo=changeE8E9AddressFromRunTimeBuffer(E8E9RunTimeAddress,runTimeAddress);
	return returnAddressTo;
	
}

//将RunTImeBuffer中的地址转换为E8或E9指令后面跳转的地址的硬编码
//E8E9RunTimeAddress:E8或E9指令运行时的地址
//rumTimeAddress:要转换的运行时地址
//返回：转换后的硬编码地址
DWORD changeE8E9AddressFromRunTimeBuffer(DWORD E8E9RunTimeAddress,DWORD rumTimeAddress){
	DWORD returnAddress=0;
	returnAddress=rumTimeAddress-(E8E9RunTimeAddress+5);
	return returnAddress;
	
}

//获得程序运行时入口的地址
//pBuffer
//返回入口地址
PBYTE getEntryRunTimeAddress(LPVOID pBuffer){
	PIMAGE_OPTIONAL_HEADER32 pOptionHeader= getOptionHeader(pBuffer);

	return (PBYTE)(pOptionHeader->ImageBase+pOptionHeader->AddressOfEntryPoint);

}

//修改程序运行时入口地址
//pImageBuffer
//imageBufferRunAddress在ImageBuffer中的地址了
void changeEntryPosByImageBufferAddress(LPVOID pImageBuffer,DWORD imageBufferRunAddress){
	PIMAGE_OPTIONAL_HEADER32 pOptionHeader= getOptionHeader(pImageBuffer);
	pOptionHeader->AddressOfEntryPoint=imageBufferRunAddress-(DWORD)pImageBuffer;
}

//修改section的权限
//pBuffer
//sectionNum Section的地址
//characteristics：具体的权限，如0x60000020
//成功，返回1，失败，返回0
DWORD changeSectionCharacteristics(LPVOID pBuffer,WORD sectionNum,DWORD characteristics){
	PIMAGE_SECTION_HEADER pSectionHeader=getSection(pBuffer,sectionNum);
	if(pSectionHeader){
		pSectionHeader->Characteristics=characteristics;
		return 1;
	}else{
		printf("changeSectionCharacteristics Failed!\n");
		return 0;
	}

}

//在pBuffer中将PE的NT头提升到Dos头下
//pBuffer
//返回值:Dos头下的间隙的大小，0:Dos头下没有间隙
DWORD topPENTHeader(IN LPVOID pBuffer){
	DWORD copySize=0;
	PIMAGE_DOS_HEADER dosHeader = getDosHeader(pBuffer);
	PIMAGE_NT_HEADERS ntHeader = getNTHeader(pBuffer);
	PIMAGE_FILE_HEADER fileHeader = getPEHeader(pBuffer);
	WORD sectionNum=getSectionNum(pBuffer);
	//Dos废数据字段的开头
	DWORD endDosPointNext=(DWORD)pBuffer+sizeof(IMAGE_DOS_HEADER);


	copySize=0;

	if((DWORD)ntHeader>endDosPointNext || (DWORD)ntHeader==endDosPointNext){
		copySize=(DWORD)ntHeader-endDosPointNext;
	}else{
		printf("topPENTHeader failed---ntHeader<endDosPointNext");

	}

	if(!copySize && sectionNum<1){
		return copySize;
	}
	
	//获得第一个节表头
	PIMAGE_SECTION_HEADER pSectionHeader1 = getSection(pBuffer,1);

	//提升NT头，并将原NT头剩余的部分置0
	*((PIMAGE_NT_HEADERS)endDosPointNext)=*ntHeader;
	
	PIMAGE_SECTION_HEADER newPSectionHeader1=(PIMAGE_SECTION_HEADER)((PIMAGE_NT_HEADERS)endDosPointNext+1);
	int i=0;

	for(i=0;i<sectionNum;i++){
		*(newPSectionHeader1+i)=*(pSectionHeader1+i);
	}


	char* fillZeroStart=(char*)(newPSectionHeader1+sectionNum);

	for(i=0;i<copySize;i++){
		*(fillZeroStart+i)=0;
	}
	
	dosHeader->e_lfanew=(endDosPointNext-(DWORD)pBuffer);

	return copySize;
}